# 为什么数据库文件不建议提交：你提交的不是数据，是未来的麻烦

你有没有遇到过这种场景：项目刚起步，大家图省事，把本地的 `app.db`（SQLite）、`data.mv.db`（H2）、甚至某个 `dump.sql` 一起丢进 Git。短期看起来很爽——拉下来就能跑、数据也现成。

但过不了多久，你会发现：仓库越来越大、合并越来越痛、线上问题越来越难复现，甚至还会在某一天突然意识到“我们把生产数据提交上去了”。

这篇文章想讲清楚一件事：**数据库文件不是源代码，它更像“运行时产物”**。把它提交到版本库，通常是在把不可控的状态带入协作系统。

## 1. Git 适合管理“可文本 diff 的历史”，不适合管理“不断变化的二进制状态”

Git 的强项是：代码是文本、差异清晰、合并可控、冲突可解决。你改了一个函数，Git 可以精确告诉你改了哪几行。

但数据库文件（尤其是 SQLite 这类单文件数据库）本质上是二进制结构。你往表里插入一行数据，可能导致多个页（page）被重写；你更新一个字段，可能触发页分裂、空洞回收、B-Tree 重平衡。

结果就是：

- 你改动很小，但 Git 看见的是“整个文件都变了”。
- 你想对比数据变化，但 `git diff` 基本无能为力。
- 你想做三方合并（3-way merge），Git 也做不了，最后只能二选一：保留谁的数据库文件？

这不是工具的问题，而是对象类型不匹配：**Git 管“描述系统的文本”，数据库文件是“系统运行后的状态快照”。**

## 2. 合并冲突会变成“不可修复”的冲突

代码冲突通常可以手工修：你看懂两边改了什么，然后合到一起。

数据库文件的冲突很不一样：

- Git 无法逐行合并二进制文件。
- 即便你强行选择一边，另一边的“新增数据”就永久丢失。
- 更糟糕的是，很多团队会因此形成坏习惯：冲突时直接 `git checkout --theirs app.db`，变成“谁最后提交谁说了算”。

当“数据状态”被纳入协作主线，你就会开始争夺一个不该被争夺的东西：**运行时状态的控制权**。

## 3. 仓库会不可逆地膨胀，且很难再瘦回去

数据库文件的增长是“滚雪球”的：

- 即便你后来删掉了 `app.db`，它的历史仍在 Git 对象库里。
- 只要某个提交里出现过大文件，所有 clone 的人都会被迫下载历史。
- `git gc` 也救不了你，因为这是“历史事实”。

很多团队第一次意识到这个问题，是在某天新同事拉仓库发现要下几百 MB，甚至几个 GB；CI 也变慢；每次 fetch/pull 都很痛。

如果你真的经历过一次“清理 Git 历史删除大文件”，你会懂这件事有多折腾：需要重写历史、强推、通知所有人重新 clone，还可能影响已发布的 tag。

## 4. 最大的雷：安全与合规风险（这不是‘可能’，是‘迟早’）

数据库文件通常包含：

- 用户信息（邮箱、手机号、头像、地址）
- 订单/交易数据
- access token、第三方密钥（很多人会把 token 存到表里）
- 内部业务规则与运营数据

一旦提交到 Git：

- 就算你立刻删掉文件，历史里依然保留。
- 私有仓库也不等于安全：成员变动、误配置、备份外泄、第三方扫描，风险路径太多。
- 一旦触达隐私/合规要求（比如数据最小化、数据留存政策），你要解释“为什么生产数据会进入版本库”。

工程上最稳妥的原则是：**版本库只存可公开的、可审计的、可复现的源资产**。真实数据属于另一套治理体系。

## 5. 复现性反而会变差：你得到的是“某个瞬间的数据库”，不是“可再生的系统”

把数据库文件提交上去，看似提升复现性：大家拿到同一个 `app.db`。

但长期看，复现性会下降，因为：

- 这个数据库文件和当前代码版本不一定匹配（schema 可能已经变化）。
- 你无法知道它是怎么生成的（缺少可审计的迁移/初始化过程）。
- 你无法在 CI 中可靠重建环境（CI 不应该依赖 repo 里一坨不可解释的二进制状态）。

真正的可复现性不是“共享一个状态快照”，而是“共享生成状态的配方”。

用一句更工程化的话说：

> 你想要的是“可声明的 schema + 可重复的迁移 + 可生成的种子数据”，而不是“某个人电脑上的 db 文件”。

## 6. 最小可复现实验：用 2 分钟亲眼看到“二进制数据库”的协作问题

下面这个实验不依赖任何框架，只用 `sqlite3` 和 Git。

### 6.1 准备

在一个空目录里执行：

```bash
git init
sqlite3 app.db "CREATE TABLE users(id INTEGER PRIMARY KEY, name TEXT);"
git add app.db
git commit -m "add sqlite db"
```

此时你会发现：`git diff` 对 `app.db` 基本没有可读输出。

### 6.2 两个人同时改数据（模拟冲突）

创建两个分支各自插入一条记录：

```bash
git checkout -b alice
sqlite3 app.db "INSERT INTO users(name) VALUES('alice');"
git add app.db
git commit -m "alice adds row"

git checkout main
git checkout -b bob
sqlite3 app.db "INSERT INTO users(name) VALUES('bob');"
git add app.db
git commit -m "bob adds row"
```

尝试合并：

```bash
git checkout main
git merge alice
git merge bob
```

你很可能会得到二进制文件冲突。这个冲突不是“改几行代码”的问题，而是：**两个分支都生成了不同的状态快照，Git 不知道怎么合并状态。**

此时你只能选一个版本：

```bash
git checkout --theirs app.db  # 或 --ours
```

你选择的那个分支之外的那条数据，就没了。

这就是为什么把数据库文件纳入主线协作，最后会演变成“状态争夺”。

## 7. 正确做法：提交“迁移与初始化”，忽略“数据库文件本体”

更靠谱的实践路径通常是：

### 7.1 提交 schema/migration

- 使用迁移工具（例如各语言生态的 migration 框架）提交可读的迁移脚本。
- 迁移脚本应该是文本，可 review、可 diff、可回滚（至少可逆/可补偿）。

### 7.2 提交可再生的 seed（种子数据）

- 用 `seed.sql` 或脚本生成最小业务数据。
- 种子数据应尽量小、无敏感信息、可重复执行。

### 7.3 本地与 CI 用“可重建环境”

- 本地开发：通过脚本一键创建数据库、跑迁移、导入 seed。
- CI：每次从空库开始跑迁移，保证构建不依赖历史状态。

### 7.4 在 `.gitignore` 里忽略数据库文件

以 SQLite 为例，通常忽略：

```gitignore
*.db
*.db-journal
*.db-wal
*.db-shm
```

如果你用的是别的数据库，也同理：把它当作构建产物/运行时产物处理。

## 8. 什么时候“可以例外”？

工程里很少有绝对，但例外需要非常明确的边界。

有些团队会在以下场景考虑提交数据库文件：

- 教学/演示仓库：提供一个极小的、脱敏的示例数据库（比如几 KB），方便读者开箱即用。
- 纯只读数据包：数据来自公开数据源，且更新频率极低，文件体积可控。

即便如此，也建议优先考虑：

- 用文本格式（CSV/JSON）+ 导入脚本替代二进制数据库文件。
- 或用发布制品（release asset、对象存储）分发数据，而不是写进 Git 历史。

## 9. 回到开头：省掉今天的 5 分钟，可能会赔掉未来的 5 天

把数据库文件提交上去的诱惑，本质是“我想立刻让别人跑起来”。

但工程上的成熟做法，是让项目具备“从零生成状态”的能力：迁移是配方，seed 是食材，环境脚本是厨房；而数据库文件只是做出来的一盘菜，适合端上桌吃掉，不适合拿去当菜谱。

如果你正在搭建一个团队项目，不妨从今天开始把数据库文件从版本库里移出去，转而投资在迁移、初始化脚本与可复现的开发环境上——这会是一个越用越香的决定。

如果你们团队已经不小心提交过数据库文件，也欢迎说说你们的技术栈（SQLite / MySQL / Postgres / MongoDB）和当前协作方式，我可以帮你给一个“迁移到正确姿势”的最小改造路径。
